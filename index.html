<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>アイトラッキング + キャリブレーション（改良版）</title>
  <script src="https://webgazer.cs.brown.edu/webgazer.js"></script>
  <style>
    body { margin: 0; text-align: center; font-family: sans-serif; }
    #dot {
      position: absolute;
      width: 20px;
      height: 20px;
      background: red;
      border-radius: 50%;
      pointer-events: none;
      opacity: 0.8;
      display: none;
      z-index: 9999;
    }
    .calibration-point {
      position: absolute;
      width: 34px;
      height: 34px;
      background: blue;
      border-radius: 50%;
      cursor: pointer;
      z-index: 10000;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: bold;
    }
    #controls { margin: 12px; }
    #status { margin: 8px; }
    button { margin: 0 6px; }
  </style>
</head>
<body>
  <h1>アイトラッキング デモ（キャリブレーション付き・改良版）</h1>
  <p id="status">「キャリブレーション開始」を押してください。ブラウザがカメラ許可を求めます。</p>

  <div id="dot"></div>

  <div id="controls">
    <button id="startCalib">キャリブレーション開始</button>
    <button id="recalib" disabled>再キャリブレーション</button>
    <button id="download" disabled>ログをCSVでダウンロード</button>
  </div>

  <script>
  // ----------------------------
  // 基本設定 / 変数
  // ----------------------------
  const dot = document.getElementById("dot");
  const statusEl = document.getElementById("status");
  const startBtn = document.getElementById("startCalib");
  const recalibBtn = document.getElementById("recalib");
  const downloadBtn = document.getElementById("download");

  // キャリブレーション位置（%）とラベル
  const calibrationPoints = [
    {x: 5, y: 5,  label: "1"}, {x:50, y:5,  label: "2"}, {x:95, y:5,  label: "3"},
    {x: 5, y:50, label: "4"}, {x:50, y:50, label: "5"}, {x:95, y:50, label: "6"},
    {x: 5, y:95, label: "7"}, {x:50, y:95, label: "8"}, {x:95, y:95, label: "9"}
  ];

  let currentPoint = 0;
  let collecting = false;
  let isTracking = false;
  let logs = []; // {t, x, y, element}
  let smoothX = null, smoothY = null;
  const SMOOTH_ALPHA = 0.25; // EMA係数: 0-1（大きいほど追従早い）
  const SAMPLES_PER_POINT = 30; // 各キャリブレーション点で収集するサンプル数
  const SAMPLE_INTERVAL_MS = 50; // サンプル間隔

  // ----------------------------
  // WebGazer 初期設定（顔映像は非表示）
  // ----------------------------
  // 非表示設定は begin() の前に呼ぶほうが確実
  webgazer.showVideo(false).showFaceOverlay(false).showFaceFeedbackBox(false);

  // setRegression / setTracker は optional（デフォルトで動くが明示）
  webgazer.setRegression('ridge');
  webgazer.setTracker('clmtrackr');

  // ----------------------------
  // ヘルパー関数
  // ----------------------------
  function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

  function pageCoordsFromWebgazer(data) {
    // data.x / data.y は画面上のピクセル座標（多くの環境で viewport 相対）
    // 致命的な環境差があれば調整が必要。
    return { x: data.x, y: data.y };
  }

  function getElementUnderGaze(x, y) {
    // elementFromPoint はクライアント（viewport）座標を要求する
    // data.x/data.y が document 全体座標（scroll を含む）なら調整が要る
    const clientX = x - window.scrollX;
    const clientY = y - window.scrollY;
    try {
      return document.elementFromPoint(clientX, clientY);
    } catch (e) {
      return null;
    }
  }

  function pushLog(x, y) {
    const el = getElementUnderGaze(x, y);
    logs.push({
      t: new Date().toISOString(),
      x: Math.round(x),
      y: Math.round(y),
      element: el ? (el.id || el.tagName || 'unknown') : ''
    });
    downloadBtn.disabled = false;
  }

  function downloadCSV() {
    if (!logs.length) { alert("ログがありません"); return; }
    const header = ["time","x","y","element"];
    const rows = logs.map(r => [r.t, r.x, r.y, `"${String(r.element).replace(/"/g,'""')}"`].join(","));
    const csv = [header.join(","), ...rows].join("\n");
    const blob = new Blob([csv], {type: "text/csv;charset=utf-8;"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `gaze_log_${(new Date()).toISOString().replace(/[:.]/g,"-")}.csv`;
    a.click();
    URL.revokeObjectURL(url);
  }

  // ----------------------------
  // キャリブレーション点を表示して自動サンプリング
  // クリック式より、"表示して注視→自動で複数サンプル" の方が安定
  // ----------------------------
  async function collectSamplesAtPoint(point, label) {
    // point: {x: %, y: %} => 実座標
    const px = Math.round(window.innerWidth * (point.x/100));
    const py = Math.round(window.innerHeight * (point.y/100));

    // 視覚的に点を出す
    const div = document.createElement("div");
    div.className = "calibration-point";
    div.style.left = `calc(${point.x}% - 17px)`;
    div.style.top = `calc(${point.y}% - 17px)`;
    div.textContent = label || '';
    document.body.appendChild(div);

    statusEl.textContent = `点 ${label} を注視してください（${SAMPLES_PER_POINT} サンプル収集）`;

    // 少し待って視線を安定させる（最初の500msはガイド）
    await sleep(600);

    // SAMPLES_PER_POINT 回、recordScreenPosition を呼びデータを蓄える
    for (let i=0; i<SAMPLES_PER_POINT; i++) {
      // webgazer.recordScreenPosition(x, y, label) を使って学習サンプルを追加
      webgazer.recordScreenPosition(px, py, 'calib');
      await sleep(SAMPLE_INTERVAL_MS);
    }

    document.body.removeChild(div);
  }

  // ----------------------------
  // キャリブレーションのワークフロー
  // ----------------------------
  async function runCalibration() {
    if (collecting) return;
    collecting = true;
    logs = []; // 新しい実験ならログをクリア
    currentPoint = 0;
    statusEl.textContent = "キャリブレーションを開始します。カメラ許可が必要です。";

    // webgazer の begin を確実に呼ぶ（これが getUserMedia を要求）
    await webgazer.begin();

    // 収集ループ
    for (let i=0; i<calibrationPoints.length; i++) {
      const p = calibrationPoints[i];
      await collectSamplesAtPoint(p, p.label);
      currentPoint++;
    }

    statusEl.textContent = "全点収集完了。モデルを学習します...";
    // 学習（これにより収集したサンプルが回帰に反映される）
    try {
      webgazer.trainRegression();
    } catch (e) {
      console.warn("trainRegression error:", e);
    }

    statusEl.textContent = "キャリブレーション完了！ トラッキングを開始します。";
    startTracking();
    collecting = false;
    recalibBtn.disabled = false;
  }

  // ----------------------------
  // トラッキング開始（setGazeListener 登録）
  // ----------------------------
  function startTracking() {
    if (isTracking) return;
    isTracking = true;
    dot.style.display = "block";

    webgazer.setGazeListener(function(data, elapsedTime) {
      if (!data) return;
      // data.x/data.y が null の場合は無視
      if (data.x == null || data.y == null) return;

      // (1) スムージング（EMA）
      if (smoothX === null) { smoothX = data.x; smoothY = data.y; }
      smoothX = SMOOTH_ALPHA * data.x + (1 - SMOOTH_ALPHA) * smoothX;
      smoothY = SMOOTH_ALPHA * data.y + (1 - SMOOTH_ALPHA) * smoothY;

      // (2) dot を移動（data.x/data.y は画面座標）
      dot.style.left = (smoothX - 10) + "px";
      dot.style.top  = (smoothY - 10) + "px";

      // (3) ログに保存（頻度を抑えたい場合はサンプリング制御を追加）
      pushLog(smoothX, smoothY);
    }).begin();
  }

  // ----------------------------
  // UI イベント
  // ----------------------------
  startBtn.addEventListener("click", async () => {
    startBtn.disabled = true;
    await runCalibration();
  });

  recalibBtn.addEventListener("click", async () => {
    // 再キャリブレーション：モデルとサンプルをクリアして再度
    try { webgazer.clearData(); } catch(e) { console.warn(e); }
    logs = [];
    smoothX = smoothY = null;
    startBtn.disabled = false;
    recalibBtn.disabled = true;
    downloadBtn.disabled = true;
    statusEl.textContent = "再キャリブレーションの準備ができました。";
  });

  downloadBtn.addEventListener("click", downloadCSV);

  // ----------------------------
  // ページアンロード時の後始末（必要なら）
  // ----------------------------
  window.addEventListener("beforeunload", () => {
    try { webgazer.end(); } catch(e) {}
  });
  </script>
</body>
</html>
